# API签名匹配使用指南

## 快速开始

### 1. 运行main.py

```bash
python main.py
```

### 2. 选择"数据蒸馏"

```
============================================================
Flaky Test分析系统 - 快速启动
============================================================
1. 数据蒸馏
2. 数据讲解
3. 评估预测结果
4. 数据集划分
5. 退出
============================================================
请选择功能 (1-5): 1
```

### 3. 按照提示配置

```
============================================================
数据蒸馏配置
============================================================

【Step 1/5】选择测试集
请选择数据集:
  1. 主数据集
  2. K-Fold: Fold 1 Train
  3. K-Fold: Fold 1 Test
  4. K-Fold: Fold 2 Train
  5. K-Fold: Fold 2 Test
  ...

选择 (1-11): 3

✓ 测试集: fold_1_test.csv

【Step 2/5】选择训练集（用于API匹配，可选）
提示: 如果选择训练集，将使用API签名匹配来检索few-shot examples
是否使用API匹配？(y/n, 默认n): y

请选择训练集（用作知识库）:
  0. (不使用)
  1. 主数据集
  2. K-Fold: Fold 1 Train
  ...

选择 (0-11): 2

✓ 训练集: fold_1_train.csv

正在加载训练集并构建API索引...
正在预处理训练集，提取API签名...
✓ 完成！共处理 6430 个训练样本
✓ API索引构建完成:
  - 训练样本数: 6430
  - 唯一API数: 1250
  - 平均API数/样本: 18.3
  - 最常见API: assert_Equals, @Test, Assert, assert_True, Thread

请输入few-shot样本数 (默认3): 3

【Step 3/5】测试模式
1. 最后N条
2. 前N条
3. 随机N条
4. 全部数据
选择模式 (1-4, 默认1): 1

请输入数据量 (默认10): 10

【Step 4/5】并行配置
请输入并行线程数 (1-10，默认1): 1
请输入批次大小 (默认5): 5

【Step 5/5】配置确认
============================================================
测试集: fold_1_test.csv
训练集: fold_1_train.csv
API匹配: 开启 (Top-3 few-shots)
测试模式: last
数据量: 10
并行线程: 1
批次大小: 5
============================================================

确认开始？(y/n): y

🚀 开始数据蒸馏...
处理进度: 100%|██████████| 10/10 [00:45<00:00,  4.5s/it]

✓ 蒸馏完成!
  成功: 10 条
  失败: 0 条
  耗时: 45.23 秒
  输出: output/distillation_fold_1_test_last_10samples_api_top3_p1_with_id.json

📊 API匹配统计:
  - 使用训练集: fold_1_train.csv
  - Few-shot数量: 3
  - 知识库大小: 6430
```

## 典型使用场景

### 场景1: K-fold交叉验证 + API匹配

**目标**: 使用fold 1的训练集作为知识库，对fold 1的测试集进行分类

```
测试集: fold_1_test.csv (2144条)
训练集: fold_1_train.csv (6430条)
API匹配: 开启
Few-shot: 3个
```

**优势**:
- 训练集和测试集项目级独立
- API匹配提供同领域的参考案例
- few-shot examples增强LLM分类能力

### 场景2: 快速测试（小样本）

**目标**: 快速验证API匹配效果

```
测试集: 主数据集
测试模式: 最后N条
数据量: 20
训练集: 主数据集
API匹配: 开启
Few-shot: 5个
```

**优势**:
- 快速验证（<2分钟）
- 可以调整few-shot数量对比效果
- 适合参数调优

### 场景3: 无API匹配对照实验

**目标**: 对比有无API匹配的效果差异

```bash
# 实验组：使用API匹配
测试集: fold_1_test.csv
训练集: fold_1_train.csv
API匹配: 开启 (Top-3)

# 对照组：不使用API匹配
测试集: fold_1_test.csv
训练集: (不使用)
API匹配: 关闭
```

对比两组结果的准确率、F1分数等指标。

## 参数配置建议

### Few-shot数量

| 数量 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| 1-2个 | 快速测试 | 速度快、成本低 | 参考信息少 |
| **3个** | **推荐** | **平衡质量和成本** | - |
| 5-10个 | 高质量需求 | 参考案例丰富 | prompt长、成本高 |

### 训练集大小

| 大小 | API索引构建时间 | 检索质量 | 推荐 |
|------|----------------|----------|------|
| 100条 | ~2秒 | 较低 | 快速测试 |
| 1000条 | ~20秒 | 中等 | 中等规模 |
| **6000+条** | **~2分钟** | **高** | **生产使用** |

### 并行配置

| 并行线程数 | 处理速度 | API成本 | 推荐场景 |
|-----------|---------|---------|---------|
| 1 | 基准 | 正常 | 小规模测试 |
| 2-4 | 2-4x | 正常 | 中等规模 |
| 5-10 | 5-10x | 注意限流 | 大规模数据 |

## 效果评估

### 检查API匹配质量

在蒸馏过程中，查看日志中的检索结果：

```
检索Top-3相似案例...
  案例 1: 相似度=0.850, 类别=2 (Concurrency)
  案例 2: 相似度=0.720, 类别=2 (Concurrency)
  案例 3: 相似度=0.650, 类别=0 (Non-flaky)
```

**质量判断**:
- **相似度>0.5**: 高度相关，参考价值大
- **0.3-0.5**: 中等相关，有一定参考价值
- **<0.3**: 弱相关，参考价值有限

### 对比实验结果

使用评估工具对比有无API匹配的结果：

```bash
python main.py
# 选择 "3. 评估预测结果"
```

对比指标：
- **准确率 (Accuracy)**
- **F1分数 (F1-score)**
- **各类别的精确率和召回率**

## 常见问题

### Q1: 为什么相似度都很低？

**原因**:
- 测试代码差异较大
- API提取规则未覆盖特定模式
- 训练集太小

**解决**:
- 扩大训练集规模
- 检查API提取规则是否合理
- 降低`min_similarity`阈值

### Q2: API索引构建太慢？

**原因**:
- 训练集太大（>10000条）
- 代码很长

**解决**:
- 使用采样（如前5000条）
- 在强大机器上预先构建索引

### Q3: Few-shot examples没有改善效果？

**可能原因**:
- LLM本身能力已经很强
- 检索到的案例质量不高
- Prompt设计问题

**调试建议**:
- 查看实际生成的prompt
- 尝试不同的few-shot数量
- 检查检索到的案例是否相关

### Q4: 内存不足？

**原因**:
- 训练集太大
- 并行线程过多

**解决**:
- 减少训练集大小
- 降低并行线程数
- 使用流式处理

## 高级技巧

### 技巧1: 自定义API提取规则

编辑 `utils/api_matcher.py` 中的 `extract_apis` 方法：

```python
# 添加自定义规则
if 'MyCustomAPI' in code:
    apis.append('custom_MyCustomAPI')
```

### 技巧2: 使用多样性检索

修改 `agents/distillation_agent.py` 中的检索调用：

```python
similar_cases = self.api_matcher.retrieve_with_diversity(
    full_code, 
    top_k=self.top_k_shots,
    diversity_threshold=0.3
)
```

### 技巧3: 缓存API索引

保存已构建的API匹配器：

```python
import pickle

# 保存
with open('api_matcher.pkl', 'wb') as f:
    pickle.dump(api_matcher, f)

# 加载
with open('api_matcher.pkl', 'rb') as f:
    api_matcher = pickle.load(f)
```

## 相关文件

- **实现**: `utils/api_matcher.py`
- **集成**: `agents/distillation_agent.py`
- **入口**: `main.py`
- **测试**: `test_api_matcher.py`, `test_integration.py`
- **示例**: `example_api_matching.py`
- **文档**: `docs/API_MATCHING.md`

## 总结

API签名匹配为数据蒸馏提供了基于代码结构的few-shot learning能力，核心优势：

✅ **快速**: 无需向量数据库，秒级检索  
✅ **准确**: 基于实际API调用，相关性高  
✅ **灵活**: 支持自定义规则和参数  
✅ **易用**: 通过main.py交互式配置  

建议配置：
- **Few-shot数量**: 3个
- **训练集**: 使用K-fold对应的训练集
- **并行线程**: 根据API限制调整

祝使用愉快！🎉
